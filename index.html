<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Dispatch: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Dispatch
   &#160;<span id="projectnumber">0.0.2 (release)</span>
   </div>
   <div id="projectbrief">Unit and Performances Testing</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Main Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#main-preface">Preface</a></li>
<li class="level1"><a href="#main-rationale">Rationale of Boost.Dispatch</a><ul><li class="level2"><a href="#main-free-function">Free function dispatching</a></li>
<li class="level2"><a href="#main-dispatch">Boost.Dispatch in action</a></li>
</ul>
</li>
<li class="level1"><a href="#main-components">Main Boost.Dispatch Components</a></li>
<li class="level1"><a href="#main-howto">How to use this documentation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="main-preface"></a>
Preface</h1>
<hr/>
<p> Boost.Dispatch is a Boost candidate library that aims at providing an idiomatic way to use tag dispatching in a way functions can be extended or specialized, with each specialization being able to be generic with the minimal amount of work required. With tag dispatching, it becomes then possible to select the best specialization for the arguments provided, avoiding the limitations inherent to unconstrained template function overloads.</p>
<h1><a class="anchor" id="main-rationale"></a>
Rationale of Boost.Dispatch</h1>
<hr/>
<p>The objective of Boost.Dispatch is to allow a flexible, scalable and easily extensible system for writing functions and functors dispatching using a generic Tag Dispatching system. This section will discuss what are the current options and why Boost.Dispatch helps making this idiom more generic and usable.</p>
<h2><a class="anchor" id="main-free-function"></a>
Free function dispatching</h2>
<p>Let us consider a fairly artificial scenario, but representative of things that are quite common in generic programming: we want to define a unary function <code>f</code>, for all built-in arithmetic types, that implements different algorithms depending on the actual type of the argument. For example, consider that <code>f</code> returns 0 if its argument is a floating point value, returns 1 if it is a signed integer or return 2 otherwise. You could do this using <em>SFINAE</em> and <code>boost::enable_if</code> in the following way:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value,<span class="keywordtype">int</span>&gt;::type f(T)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value &gt;,<span class="keywordtype">int</span>&gt;::type f(T)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_signed&lt;T&gt;::value &amp;&amp; std::is_integral&lt;T&gt;::value &gt;,<span class="keywordtype">int</span>&gt;::type f(T)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The SFINAE approach clearly doesn't scale in terms of programming, since all overloads must be mutually exclusive, but also in terms of compilation times, since SFINAE-based overload resolution is linear.</p>
<p>Another solution, which is heralded by the Standard Template Library itself is to use a technique known as Tag Dispatching:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>unknown_tag                              {};</div>
<div class="line"><span class="keyword">struct </span>fundamental_tag                          {};</div>
<div class="line"><span class="keyword">struct </span>floating_point_tag     : fundamental_tag {};</div>
<div class="line"><span class="keyword">struct </span>integral_tag           : fundamental_tag {};</div>
<div class="line"><span class="keyword">struct </span>signed_integral_tag    : integral_tag    {};</div>
<div class="line"><span class="keyword">struct </span>unsigned_integral_tag  : integral_tag    {};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="keyword">struct </span>category_of                { <span class="keyword">typedef</span> unknown_tag type;           };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;            <span class="keyword">struct </span>category_of&lt;float&gt;         { <span class="keyword">typedef</span> floating_point_tag type;    };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;            <span class="keyword">struct </span>category_of&lt;double&gt;        { <span class="keyword">typedef</span> floating_point_tag type;    };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;            <span class="keyword">struct </span>category_of&lt;int&gt;           { <span class="keyword">typedef</span> signed_integral_tag type;   };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;            <span class="keyword">struct </span>category_of&lt;unsigned int&gt;  { <span class="keyword">typedef</span> unsigned_integral_tag type; };</div>
<div class="line"></div>
<div class="line"><span class="comment">/* etc. for all other fundamental types... */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T t)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> f(t, <span class="keyword">typename</span> category_of&lt;T&gt;::type() );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, floating_point_tag <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, integral_tag <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, unsigned_integral_tag <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p> By using a hierarchy of types bound by inheritance, it's possible to make use of the best-match feature of C++ overloading to introduce specializations without requiring them to be mutually exclusive. The <code>iterator_category</code> system of standard iterators is a good example of that.</p>
<p>Doing this in a clean, concise, reusable and idiomatic manner is however of some difficulty, which is why that is only done in an ad-hoc way in practice.</p>
<h2><a class="anchor" id="main-dispatch"></a>
Boost.Dispatch in action</h2>
<p>Boost.Dispatch solves these problems through two related components:</p>
<ul>
<li>An extensible hierarchy system that contains ready-made hierarchies and that can be easily extended. This provides a powerful and idiomatic way to define tags embedding arbitrary level of intentionality.</li>
<li>A dispatching mechanism built on top of the hierarchies and overloading, that automates the use of tag dispatching with one or all arguments.</li>
</ul>
<p>Here is what the free function example looks like when written with Boost.Dispatch:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/dispatch/hierarchy_of.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1dispatch.html">boost::dispatch</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T t)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> f(t, hierarchy_of(t) );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, scalar_&lt; floating_&lt;T&gt; &gt; <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, scalar_&lt; integer_&lt;T&gt; &gt; <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">int</span> f(T, scalar_&lt; unsigned_&lt;T&gt; &gt; <span class="keyword">const</span>&amp;)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Notice how the second specialization applies to any integral type, including unsigned ones. However, since there is also a specialization for unsigned types, the latter gets preferred, since <code>unsigned_</code> is a refinement of <code>integer_</code> in the built-in hierarchies.</p>
<h1><a class="anchor" id="main-components"></a>
Main Boost.Dispatch Components</h1>
<hr/>
<p>xxx</p>
<h1><a class="anchor" id="main-howto"></a>
How to use this documentation</h1>
<hr/>
<p> The structure of the reference (available in the menu to the left) goes as follow:</p>
<ul>
<li><a class="el" href="group__group-concept.html">Concepts</a><br />
 Concepts defined and used throughout Boost.Dispatch.</li>
<li><a class="el" href="group__group-meta.html">Meta-programming Utilities</a><br />
 Those functions, classes and macros are components related to the meta-programming required to make Boost.Dispatch works.</li>
<li><a class="el" href="group__group-extension.html">Extension points</a><br />
 Documentation for extension points for library's components. This documentation is useful for people wanting to extended Boost.Dispatch to work with their own types.</li>
<li><a class="el" href="group__group-adapted.html">External adapters</a><br />
 Documentation for the predefined adaptation of external types to be usable with the library.</li>
<li><a class="el" href="group__group-detail.html">Implementation details</a><br />
 Documentation for implementation details of the library. This documentation is useful for people wanting to work on the library internals and provide patches.</li>
</ul>
<hr/>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
